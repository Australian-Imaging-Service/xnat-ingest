import typing as ty
import attrs
from fileformats.core import DataType
from frametree.core.frameset import FrameSet  # type: ignore[import-untyped]
from frametree.core.axes import Axes  # type: ignore[import-untyped]
from frametree.core.row import DataRow  # type: ignore[import-untyped]
from frametree.core.store import Store  # type: ignore[import-untyped]
from frametree.core.entry import DataEntry  # type: ignore[import-untyped]
from frametree.core.tree import DataTree  # type: ignore[import-untyped]
from .session import ImagingSession


@attrs.define
class ImagingSessionMockStore(Store):  # type: ignore[misc]
    """Mock data store so we can use the column.match_entry method on the "entries" in
    the data row
    """

    session: ImagingSession

    @property
    def row(self) -> DataRow:
        return DataRow(
            ids={DummyAxes._: None},
            frameset=FrameSet(id=None, store=self, hierarchy=[], axes=DummyAxes),
            frequency=DummyAxes._,
        )

    def populate_row(self, row: DataRow) -> None:
        """
        Populate a row with all data entries found in the corresponding node in the data
        store (e.g. files within a directory, scans within an XNAT session) using the
        ``DataRow.add_entry`` method. Within a node/row there are assumed to be two types
        of entries, "primary" entries (e.g. acquired scans) common to all analyses performed
        on the dataset and "derivative" entries corresponding to intermediate outputs
        of previously performed analyses. These types should be stored in separate
        namespaces so there is no chance of a derivative overriding a primary data item.

        The name of the dataset/analysis a derivative was generated by is appended to
        to a base path, delimited by "@", e.g. "brain_mask@my_analysis". The dataset
        name is left blank by default, in which case "@" is just appended to the
        derivative path, i.e. "brain_mask@".

        Parameters
        ----------
        row : DataRow
            The row to populate with entries
        """
        for scan_id, scan in self.session.scans.items():
            for resource_name, resource in scan.resources.items():
                row.add_entry(
                    path=scan.type + "/" + resource_name,
                    datatype=resource.datatype,
                    uri=(scan_id, resource_name),
                )

    def get(self, entry: DataEntry, datatype: type) -> DataType:
        """
        Gets the data item corresponding to the given entry

        Parameters
        ----------
        entry : DataEntry
            the data entry to update
        datatype : type
            the datatype to interpret the entry's item as

        Returns
        -------
        item : DataType
            the item stored within the specified entry
        """
        scan_id, resource_name = entry.uri
        return datatype(self.session.scans[scan_id][resource_name])  # type: ignore[no-any-return]

    ######################################
    # The following methods can be empty #
    ######################################

    def populate_tree(self, tree: DataTree) -> None:
        pass

    def connect(self) -> ty.Any:
        pass

    def disconnect(self, session: ty.Any) -> None:
        pass

    def create_data_tree(
        self,
        id: str,
        leaves: ty.List[ty.Tuple[str, ...]],
        hierarchy: ty.List[str],
        axes: type,
        **kwargs: ty.Any,
    ) -> DataTree:
        raise NotImplementedError

    ###################################
    # The following shouldn't be used #
    ###################################

    def put(self, item: DataType, entry: DataEntry) -> DataType:
        raise NotImplementedError

    def put_provenance(
        self, provenance: ty.Dict[str, ty.Any], entry: DataEntry
    ) -> None:
        raise NotImplementedError

    def get_provenance(self, entry: DataEntry) -> ty.Dict[str, ty.Any]:
        raise NotImplementedError

    def save_frameset_definition(
        self, dataset_id: str, definition: ty.Dict[str, ty.Any], name: str
    ) -> None:
        raise NotImplementedError

    def load_frameset_definition(
        self, dataset_id: str, name: str
    ) -> ty.Dict[str, ty.Any]:
        raise NotImplementedError

    def site_licenses_dataset(self) -> FrameSet:
        raise NotImplementedError

    def create_entry(self, path: str, datatype: type, row: DataRow) -> DataEntry:
        raise NotImplementedError


class DummyAxes(Axes):  # type: ignore[misc]
    _ = 0b0
